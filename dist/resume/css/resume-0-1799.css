.skill-wave,
.skill-progress {
  display: none;
}
.resume-page {
  padding-bottom: 50px;
}
.header,
.main {
}

.section {
  max-width: 960px;
  margin: 30px auto;
}
.section--info {
  font-size: 16px;
  line-height: 2;
  padding: 0 20px;
}

/* 技术栈 */
.skill-graph .skill-wrap {
  position: relative;
  color: rgba(255, 255, 255, .7);
  overflow: hidden;
}
.skill-graph .skill-wrap::after {
  content: '';
  position: absolute;
  top: 37%;
  left: 33.5%;
  display: inline-block;
  width: 56px;
  height: 10px;
  background: linear-gradient(to right, transparent 0%, grey 15%, #000 25%, #35363c 35%, #2b282a 65%, #000 75%, grey 85%, transparent 0%);
}
.skill-desc-block {
  position: relative;
  width: 300px;
  height: 400px;
  padding: 20px;
  margin: 0 30px;
}
.skill-graph-block::before,
.skill-desc-block::after {
  content: '';
  position: absolute;
  top: 41%;
  display: inline-block;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background-color: #2eac6d;
  box-shadow: inset 0 -3px 3px 0 rgba(0, 0, 0, .4), inset -3px 0 3px 0 rgba(0, 0, 0, .4);
}
.skill-desc-block::after {
  right: 7px;
}
.skill-graph-block::before {
  left: 7px;
}
.skill-desc-item {
  line-height: 2;
  overflow: hidden;
}
.skill-desc-list .desc-name {
  font-size: 16px;
}
.skill-desc-list .desc-detail {
  float: right;
  font-size: 12px;
  color: #aaa;
  text-align: right;
  margin-left: 50px;
}
.skill-desc-list .desc-level,
.desc-progress-bar {
  display: none;
}
.skill-graph-block {
  position: relative;
  width: 550px;
  height: 400px;
  font-size: 12px;
  padding: 0 50px 0;
  margin: 0 30px 50px 0;
  background: repeating-linear-gradient(to top, transparent 0%, transparent 15%, #4b5160 15%, #4b5160 16%);
  background-clip: content-box;
}
.skill-y-item {
  position: absolute;
  left: 10px;
}
.skill-graph-list {
  display: flex;
  text-align: center;
  height: 100%;
  padding-top: 18px;
  padding-bottom: 64px;
}
.skill-graph-item {
  flex: 20%;
  position: relative;
}

/*
// === 浏览器渲染: === //
// === 1 特点：=== //
// === 1.1 HTML和CSS是边加载边解析边渲染, 比如50kb的HTML, 是下载到8kb时会解析渲染，再到下一个8kb时同样, 此过程DOM Tree和Render Tree是动态更新的 === //
// === 1.2 遇到script脚本会发生JS阻塞, 因为JS有能力改变DOM结构, 因此要把js脚本放在底部 === //
// === 2 流程: === //
                       DOM  <-- JS
                        |       ^
                        |      /
                        v     /
HTML ----> 解析 ----> DOM Tree
                        |               Layout
                        |                 |
                        v                 v
                    Attachment ----> Render Tree ----> Painting ----> Display
                        ^
                        |
                        |
CSS ----> 解析 ----> 样式规则
// === 3 DOM Tree和Render Tree: 除了以下情况两者都会一一对应 === //
// === 3.1 可显示的元素: 当把一个元素display: none;之后，在DOM Tree中可见但是在Render Tree中并不可见，所以若要通过js对dom进行一些操作，可以先把该dom隐藏，这样的话就可以减少了对Render Tree的影响 === //
// === 3.2 定位元素：当一个元素定位后，会脱离正常文档流而跑去其它地方，所以在DOM Tree中没有消失，在Render Tree中也只是一个占位符，那么一些复杂的动画，就可以用它来减少对Render Tree的负担 === //

// === 重排: 当几何属性改变时会触发重排 === //
// === 1 场景: === //
// === 1.1 页面第一次渲染 === //
// === 1.2 浏览器窗口尺寸改变 === //
// === 1.3 元素位置和尺寸改变 === //
// === 1.4 新增和删除可见元素 === //
// === 1.5 内容改变 === //

// === 重绘: 影响元素外观的属性改变时触发 === //
// === 1 场景: === //
// === 1.1 color, background-color等 === //
// === 2 关系: 重排必导致重绘，重绘不一定导致重排，因此能用重绘的不用重排 === //

// === 优化： === //




*/


.skill-graph-list .item-graph,
.skill-graph-list .item-name {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}
.skill-graph-list .item-graph {
  bottom: 0;
  width: 40px;
  height: 100%;
  background: linear-gradient(to right, #ff4500 0%, #ff4500 47%, #cf3a02 50%, #cf3a02 100%);
  transform-origin: 100% 100%;
  margin-left: -20px;
  animation: graphAnim .5s ease-out;
}
.skill-graph-list .item-name {
  bottom: -20px;
  width: 100px;
}
@keyframes graphAnim {
  0% {
    transform: scaleY(0);
  }
}
/* 项目经理 */
.project-list {
  margin-left: 160px;
  word-break: break-all;
}
.project-item {
  padding: 15px;
}